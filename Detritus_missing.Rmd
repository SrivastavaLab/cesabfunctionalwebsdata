---
title: "Report on missing detritus"
author: "Andrew"
date: "14. 11. 2016"
output: 
  html_document:
    toc: true
    code_folding: hide
---

## Description of the problem

The amount of detritus present in a bromeliad is probably important for the insect community which we find in that plant. Fortunately, members of the BWG frequently measured the amount of detritus that they found in their plants. Unfortunately, these measurements were inconsistent: taken with different sizes of sieves, sometimes sampling all possible detritus and sometimes leaving out the largest or smallest categories. 

The good news is, that at least sometimes we can try to fill in what we are missing. The neutral news is that such interpolation/extrapolation/estimation always has error associated with it. This error will vary from dataset to dataset, depending on several factors:

* the number of other variables measured
* the modelling framework used
* sample size
* vagaries of any particular bromeliad and/or the leaves that fall into it.

This report aims to summarize what we know and how we know it, regarding the interpolation of detritus amounts. 

## State of the Data

Within a **visit**, the techniques used to collect measurements should all be the same. There are three ways a visit might have incomplete detritus information: 

### Sites with no detritus

We know that at several sites, no detritus information at all was collected. How many such sites are there?

```{r}

the_detritus_list <- detritus_wider_cardoso_corrected %>% 
  nest(-visit_id, -dataset_id, -dataset_name) %>% 
  mutate(data_det = map(data, ~ .x %>% 
                          select(starts_with("detritus"))),
         data_present_values = map(data_det, ~ .x[which(colSums(is.na(.x)) < nrow(.x))]))

is_there_detritus <- the_detritus_list %>% 
  mutate(has_detritus = map_chr(data_present_values, ~ ifelse(ncol(.x) > 0, "at least some", "none")),
         total_brom   = map_dbl(data_present_values, nrow)) 

count_the_detritus <- is_there_detritus %>% 
  group_by(has_detritus) %>% 
  summarize(total_bromeliad = sum(total_brom),
            total_site = n())

count_the_detritus %>% 
  gather(var, count, starts_with("total")) %>% 
  ggplot(aes(x = has_detritus, y = count)) +
  geom_bar(stat = "identity", fill = "lightgreen") + 
  facet_wrap(~var, scales = "free_y", labeller = labeller(var = c(total_bromeliad = "Number of bromeliads",
                                                                  total_site     = "Number of sites"))) + 
  theme_minimal() +
  xlab("Is there any detritus in the raw data?")
```

The datasets with no detritus data at all are:

```{r results='asis'}
is_there_detritus %>% 
  filter(has_detritus == "none") %>% 
  .[["dataset_name"]] %>% 
  unique %>%
  map_chr(~ paste0("* *", .x, "*\n")) %>% 
  cat
```

### Sites with at least some -- how much is missing?

```{r}
detritus_categories <- is_there_detritus %>% 
  filter(has_detritus == "at least some") %>% 
  mutate(category_names = data_present_values %>% map(colnames)) %>% 
  unnest(category_names) %>% 
  select(dataset_id, visit_id, dataset_name, category_names) %>% 
  distinct() %>% 
  arrange(dataset_name)


detritus_ranges <- detritus_categories %>% 
  separate(category_names, into = c("min", "max"), sep = "_", remove = FALSE) %>%
  mutate(min = readr::parse_number(min),
         max = readr::parse_number(max)) %>% 
  rowwise %>% 
  mutate(med = median(c(min, max))) %>% 
  ungroup %>% 
  mutate(med = ifelse(is.na(max), 25000, med)) %>% 
  group_by(dataset_name) %>% 
  arrange(dataset_name, med) %>% 
  ungroup
```


```{r}

count_sieves <- detritus_ranges %>% 
  nest(-dataset_id, -dataset_name, -visit_id) %>% 
  mutate(no_seives = map_dbl(data, nrow)) 


```

It seems to me that the major trouble here is that we don't have a simple way to see what _exactly_ is missing. There are three ways that we can be missing detritus : from the middle (that's impossible) from the start, and from the end

#### The middle
```{r}
one_sieve <- count_sieves%>% 
  filter(no_seives == 1)

more_sieves <- count_sieves %>% 
  filter(no_seives > 2)

continuous_sieve <- more_sieves %>% 
  mutate(data_sieve_seq = data %>% map( ~ .x %>% 
                                          mutate(sieve_sing = dense_rank(med)))) %>% 
  mutate(contin = data_sieve_seq %>% map(~ .x %>% 
                                           ## the maximum of a sieve should be
                                           ## the same as the last minimum
                                           mutate(sames = max == lead(min))))


continuous_sieve %>% 
  mutate(no_missing_middle = contin %>% map_lgl(~ all(.x$sames[-nrow(.x)]))) %>% 
  filter(!no_missing_middle)

```

### the start or the end?


Let's see if we can visualize, for all sites with more than one sieve, the range of the data:

```{r fig.width=9}
detritus_ranges %>% 
  replace_na(list(max = 40000)) %>%
  arrange(dataset_name) %>% 
  ggplot(aes(x = visit_id, ymin = min, ymax = max, colour = category_names)) +
  scale_y_continuous(trans = "log2") +
  geom_hline(yintercept = 40000, lwd = 0.8, colour = "lightgrey", lty = 2) +
  geom_errorbar(width = 0.4, lwd = 1.2) +
  theme_minimal() +
  theme(legend.position = "bottom", axis.text.x = element_text(size = 6))
  # geom_text(aes(y = med, label = dataset_name), angle = 90)
```

## Filling in those missing values

### Puerto Rico 2010

From original document comments: 

> Although Puerto Rico 2010 dataset=116 based only on relaxed diameter the adj r sq is 0.79
#eqn from all 1990s El verde plants (n=189, rsq = 0.78) interestingly v. similar eqn from pitilla 2002 secondary


```{r}

elverde90s <- detritus_wider %>%
  filter(dataset_id %in% c(131, 126, 121, 221))

elverde90s %>% .[["visit_id"]] %>% unique



elverde90s$detritus0_NA <- with(elverde90s, detritus10_1500 + detritus1500_20000 + detritus20000_NA)

mod <- glm(log(detritus0_NA)~log(diameter), data=elverde90s)

mod %>% tidy %>% kable

mod %>% glance() %>% kable()

```

```{r}
plot(elverde90s$detritus0_NA~elverde90s$diameter)

total_elverde2010 <- function(dia){
  exp(-6.223+ 2.179* log(dia))
}
curve(total_elverde2010(x), add = TRUE)


plot(log(elverde90s$detritus0_NA) ~ log(elverde90s$diameter))

total_elverde2010 <- function(dia){
  -6.223+ 2.179*(dia)
}

curve(total_elverde2010(x), add = TRUE)

detritus_wider<-detritus_wider %>%
  mutate(detritus0_NA = ifelse(dataset_id == 116, total_elverde2010(diameter), NA))

```

