---
title: "Report on missing detritus"
author: "Andrew"
date: "14. 11. 2016"
output: 
  html_document:
    toc: true
    code_folding: hide
---

## Description of the problem

The amount of detritus present in a bromeliad is probably important for the insect community which we find in that plant. Fortunately, members of the BWG frequently measured the amount of detritus that they found in their plants. Unfortunately, these measurements were inconsistent: taken with different sizes of sieves, sometimes sampling all possible detritus and sometimes leaving out the largest or smallest categories. 

The good news is, that at least sometimes we can try to fill in what we are missing. The neutral news is that such interpolation/extrapolation/estimation always has error associated with it. This error will vary from dataset to dataset, depending on several factors:

* the number of other variables measured
* the modelling framework used
* sample size
* vagaries of any particular bromeliad and/or the leaves that fall into it.

This report aims to summarize what we know and how we know it, regarding the interpolation of detritus traits. 

## State of the Data

Here is what we know so far:

### Sites with no detritus

```{r}

the_detritus_list <- detritus_wider %>% 
  nest(-visit_id, -dataset_id, -dataset_name) %>% 
  mutate(data_det = map(data, ~ .x %>% 
                          select(starts_with("detritus"))),
         data_present_values = map(data_det, ~ .x[which(colSums(is.na(.x)) < nrow(.x))]))

no_detritus_at_all <- the_detritus_list %>% 
  filter(map_lgl(data_present_values, ~ ncol(.x) == 0))

at_least_some_detritus <- the_detritus_list %>% 
  filter(map_lgl(data_present_values, ~ ncol(.x) > 0))
```

We have **`r nrow(no_detritus_at_all)` visits** which have no detritus. This represents **`r no_detritus_at_all$data_present_values %>% map_dbl(nrow) %>% sum` bromeliads** out of `r the_detritus_list$data_det %>% map_dbl(nrow) %>% sum` plants in total.

The sites with no detritus data at all are

```{r}
no_detritus_at_all %>% 
  select(visit_id, dataset_id, dataset_name) %>% 
  arrange(dataset_name) %>% 
  kable
```

_should maybe be just the dataset names_

### Sites with at least some -- how much is missing?

Let's start by looking at what detritus categories *do* exist for each ~~site~~ dataset (dataset only to keep the list short:

```{r}
detritus_categories <- at_least_some_detritus %>% 
  mutate(category_names = data_present_values %>% map(colnames)) %>% 
  unnest(category_names) %>% 
  select(dataset_id, visit_id, dataset_name, category_names) %>% 
  distinct() %>% 
  arrange(dataset_name)

detritus_categories %>% 
  kable
```



```{r}
detritus_ranges <- detritus_categories %>% 
  separate(category_names, into = c("min", "max"), sep = "_", remove = FALSE) %>%
  mutate(min = readr::parse_number(min),
         max = readr::parse_number(max)) %>% 
  rowwise %>% 
  mutate(med = median(c(min, max))) %>% 
  ungroup %>% 
  mutate(med = ifelse(is.na(max), 25000, med)) %>% 
  group_by(dataset_name) %>% 
  arrange(dataset_name, med) %>% 
  ungroup
```


```{r}

count_sieves <- detritus_ranges %>% 
  nest(-dataset_id, -dataset_name, -visit_id) %>% 
  mutate(no_seives = map_dbl(data, nrow)) 

one_sieve <- count_sieves%>% 
  filter(no_seives == 1)


more_sieves <- count_sieves %>% 
  filter(no_seives > 2)
```

It seems to me that the major trouble here is that we don't have a simple way to see what _exactly_ is missing. There are three ways that we can be missing detritus : from the middle (that's impossible) from the start, and from the end

#### The middle
```{r}
continuous_sieve <- more_sieves %>% 
  mutate(data_sieve_seq = data %>% map( ~ .x %>% 
                                          mutate(sieve_sing = dense_rank(med)))) %>% 
  mutate(contin = data_sieve_seq %>% map(~ .x %>% 
                                           ## the maximum of a sieve should be
                                           ## the same as the last minimum
                                           mutate(sames = max == lead(min))))


continuous_sieve %>% 
  mutate(no_missing_middle = contin %>% map_lgl(~ all(.x$sames[-nrow(.x)]))) %>% 
  filter(!no_missing_middle)

```

## the start or the end?


Let's see if we can visualize, for all sites with more than one sieve, the range of the data:

```{r fig.width=9}
detritus_ranges %>% 
  replace_na(list(max = 40000)) %>%
  arrange(dataset_name) %>% 
  ggplot(aes(x = visit_id, ymin = min, ymax = max, colour = category_names)) +
  scale_y_log10() +
  geom_errorbar(width = 0.4) +
  theme_minimal() +
  theme(legend.position = "bottom", axis.text.x = element_text(size = 6))
  # geom_text(aes(y = med, label = dataset_name), angle = 90)
```


